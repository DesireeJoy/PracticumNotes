Intro to Animation and Transform with CSS
Transform
div {
    transform: matrix(2, 3, 4, 5, 6, 7);
}
The first parameter scales the element's width. The value of 2 above, for example, will double the element's size along the x-axis. It is equivalent to the transform value scaleX().
The second parameter 3 describes the vertical skew of an element in degrees. A positive value raises the left edge of the element and lowers the right, while a negative value does the opposite. This is equivalent to the transform value skewY().
The third parameter 4 is the horizontal skew in degrees. A positive value skews the top of the element to the left, and a negative value to the right. It is equivalent to the transform value skewX().
The fourth parameter scales the element's height. The value of 5 expands it along the y-axis by a factor of 5. It is equivalent to the transform value scaleY().
The fifth parameter 6 describes the translation of an element along the x-axis in pixels. It is equivalent to the transform value translateX().
The sixth parameter 7 describes the translation of an element along the y-axis in pixels. It is equivalent to the transform value translateY().
 
transform: translate(10px, 20px); /* moves the object 10 pixels to the right and 20 pixels down */
transform: scale(1.5, 0.5); /* enlarges the object by a factor of 1.5 horizontally and halves it vertically */
transform: rotate(30deg); /*rotates the object 30 degrees clockwise */
transform: skew(30deg, 40deg); /* skews the top side of the object 30 degrees to the left, the bottom side 30 degrees to the right, the left side 40 degrees up, and the right side 40 degrees down */

translate() is specified in pixels, but they can also be defined in relative values.
scale() is defined relative to 1. The value 1 signifies a ratio of one to one, meaning the element will not change. Values larger than 1 expand the object, while numbers less than 1 contract it.
rotate() and skew() can be defined in degrees. Negative values are allowed and are used for counterclockwise rotations and skews to the right.
The transform property can also be applied in three dimensions to create a virtual 3D effect on the screen. We won't get into the details of this here. For now, we'll just stick to the basics.

Smoothing out Transitions
transition-property describes which property is being changed.
transition-duration specifies the transition time in seconds.
transition-timing-function defines how the transition animation will behave (speed up, slow down, or move linearly).
transition-delay is the number of seconds between the change in the element's state and the start of the animation.
div {
    background-color: black;
    transition-property: background-color;
    transition-duration: 1s;
    transition-timing-function: linear;
    transition-delay: 2s;
}
 
div:hover {
    background-color: white;
}
Shorthand Version

div {
    background-color: black;
    transition: background-color 1s linear 2s;
}

div:hover {
    background-color: white;
}

Timing-function Keywords
ease
linear
ease-in
ease-out
ease-in-out
transition-timing-function: cubic-bezier(1,.2,.52,.46);
Link to custom timing graphs
https://cubic-bezier.com/#.17,.67,.83,.67

One thing to keep in mind about the transition property is that it performs best when applied to an element's canonical CSS rule rather than to its :hover rule.

Shadows
Shadows are a useful design tool. They can be applied to elements as well as text. The box-shadow property is used for block shadows.
The sequence of values for shadow properties for both text and blocks goes as follows:
Horizontal shadow offset (negative values create a shadow to the left of the object, and positive values to the right).
Vertical shadow offset (negative values create a shadow above the object, and positive values below).
Blur radius (the bigger the value, the bigger and lighter the shadow).
Shadow color (set the same way as text or background color).

In code, values are written as follows:
Copy codeCSS
div {
            box-shadow: 5px 6px 7px red;
}

h1 {
        text-shadow: 5px 6px 7px red;
}
In both examples, the shadow is offset 5px to the right and 6px down, has a blur radius of 7px, and is red in color.

Linear Gradients
 gradient allows you to fill a block with color in such a way that one color (called a color stop) smoothly transitions into another between fixed points.
In CSS, gradients are set by using the background-image property. In fact, a gradient is essentially a basic background image, except that it's generated with code.
There are two types of gradients: linear and radial.
Linear
Linear gradients are defined in code using the linear-gradient() value for background-image.

In the most simple cases, two colors are set in parentheses, separated by a comma. These are the starting and ending colors. The browser creates a smooth transition between them.
Copy codeCSS
div {
    background-image: linear-gradient(#0078FF, #C2E3E3);
}
By default, the color transition goes from top to bottom, but this can be changed. One option is to rotate the gradient by a certain amount of degrees.
For example:
Copy codeCSS
div {
    background-image: linear-gradient(90deg, #0078FF, #C2E3E3);
}
This rotates the gradient 90 degrees.

There are special keywords for the most frequently used directions, which you can use instead of degrees.

To build more complex gradients, you can use more than two colors:
Copy codeCSS
div {
    background-image: linear-gradient(#0B2337, #126DDC, #76C2E0, #D1DC9D, #F09174);
}
After setting each color, you can set the interval at which the colors should be applied. The first value is the starting point of the direction you’ve set, and the second is the final point.
Copy codeCSS
div {
    width: 300px;
    height: 300px;
    background-image: linear-gradient(#0078FF 0px 100px, #B4DEEF 100px 200px, #FF5A0A 200px 300px);
}

You can also define stop points as percentages:
Copy codeCSS
div:first-of-type {
    width: 300px;
    height: 300px;
    background-image: linear-gradient(#0078FF 20%, #C2E3E3 100%);
}
div:last-of-type {
    width: 300px;
    height: 300px;
    background-image: linear-gradient(#0078FF 80%, #C2E3E3 100%);
}
Result:

You can create some very interesting effects by combining these methods. We've only gone through the most basic gradient settings, which are usually enough for most purposes.
Radial Gradients
While colors in a linear gradient change in one direction, with radial gradients, the color changes outwards in all directions starting from a given central point. The gradient itself can be either circular or elliptical.
The most basic radial gradient is set with the radial-gradient() value as follows:
 
Copy codeCSS

div {
    background-image: radial-gradient(#0078FF, #C2E3E3);
}

The default starting point for a radial gradient is the middle of the block, but this can be changed by setting a position with the keyword at (i.e. "at this point").
Copy codeCSS
div {
    width: 300px;
    height: 300px;
    background-image: radial-gradient(at 40px 50px, #0078FF, #C2E3E3);
}
This code will position the center of the gradient 40px to the right of the left edge of the block and 50px below the upper edge.

Just like with a linear gradient, you can define colors and stop points as percentages:
Copy codeCSS
div {
    width: 300px;
    height: 300px;
    background-image: radial-gradient(#002918 10%, #B4DEEF 20%, #FFFFFF 50%, #FF5831 100%);
}
or in pixels:
Copy codeCSS
div {
    width: 300px;
    height: 300px;
    background-image: radial-gradient(#002918 50px, #B4DEEF 70px, #FFFFFF 100px, #FF5831 200px);
}
You can also set exact intervals to create a hard-edged gradient, where the color transition is not smooth:
Copy codeCSS
div {
    width: 300px;
    height: 300px;
    background-image: radial-gradient(#002918 0px 20px, #B4DEEF 20px 40px, #FFFFFF 40px 60px, #FF5831 60px 80px);
}

By setting a width and height in the first parameter of the parentheses, you can either stretch or collapse the ellipse.
Copy codeCSS
div {
    width: 300px;
    height: 300px;
    background-image: radial-gradient(40px 100px, #0078FF, #C2E3E3);
}
or
Copy codeCSS
div {
    width: 300px;
    height: 300px;
    background-image: radial-gradient(100px 40px, #0078FF, #C2E3E3);
}

There's documentation available that outlines many more things you can do with radial gradients. For now, we've just introduced you to the most basic features.

Block Overflow
Let’s find out what happens when you try to place a block that's 500×500 in a block that’s 300×600.
First we're going to nest a div element with an inner class in a parent div with an outer class:
Copy codeHTML
<div class="outer">
    <div class="inner"></div>
</div>
Now, using a CSS rule, we set the width of the inner block to be wider than the outer block. We'll also set different colors for each of them:
Copy codeCSS
.outer {
    width: 300px;
    height: 600px;
    background-color: rgb(1, 163, 114);
}

.inner {
    width: 500px;
    height: 500px;
    background-color: rgba(0, 120, 255, .8);
}
Result:

When a large block goes beyond the dimensions of its smaller parent, the whole block is still visible by default. In CSS, this situation is called an overflow. When this happens, we can define the parent block's behaviour with the overflow property, which has three possible values:
auto is the default value.
scroll hides the areas outside the boundaries of the block, but allows you to scroll inside the parent block to see the rest of the overflowed element.
hidden hides the parts that don't fit.

You can also set more specific values with these sub-properties:
overflow-x defines the horizontal behavior.
overflow-y defines the vertical behavior.
In this example, we've added an overflow property with a value of hidden:
Copy codeCSS
.outer {
    width: 300px;
    height: 600px;
    background-color: rgb(1, 163, 114);
    overflow: hidden;
}

.inner {
    width: 500px;
    height: 500px;
    background-color: rgba(0, 120, 255, .8);
}
Anything that doesn't fit the parent's dimensions is hidden:

Keyframes
So far in this chapter, we've only discussed simple transformations. Now it's time to move on to more complicated ones. This is where keyframes come in.
First of all, let’s look at how animations work in general. A movie, for example, is just a collection of still images. They change so quickly that it seems like the picture is moving. Animations work in a similar way. The browser renders different states of the animated object one after another at such a high speed, that all you see is a smooth transition. Just like with movies, each of these states is called a frame.
In the second lesson of this chapter, we looked at this example:
Copy codeCSS
div {
    background-color: black;
    transition: background-color 2s linear 0s;
}
This code tells the <div> element to smoothly change its color. The animation has two keyframes. There's the first frame, in which the background is transparent, and the last frame, where it's black. The animation shows the element’s state changing smoothly from one to the other.
To recap, an animation is made up of frames. Keyframes are the frames where we set the states of an element that we want to transition between. All the intermediate frames required to make these transitions smooth are automatically generated by the browser.
You can create an animation using keyframes as follows:
1. Describe the state of the element in each keyframe.
2. Use a selector to choose the element you want to animate.
3. Set specific behavior for the animation, such as how many times it should repeat, the duration, and timing function. We'll get into this in more detail later.
Stage 1: Describing the transformation
Keyframes are declared with the @keyframes at-rule. All at-rules are written after the @ sign.
You must include a name when you declare a keyframe, as you'll need it to implement the animation. The name comes right after the at-rule, with a space:
@keyframes name_of_keyframe.

Keyframe rules are followed by a pair of curly braces, where the "body" of the keyframe goes.

@keyframes name_of_keyframe {
    <rules specifying changes to the style go here>
}
The element's CSS declarations are specified in curly brackets for each keyframe. Keyframes are written as percentages. 0% refers to the start of the animation, 50% to the middle, 100% to the end, and so on.

Multiple State Animation Markup
@keyframes move {
    0% {
        left: 0;
        top: 0;
    }
    25% {
        left: 30px;
        top: 30px;
    }
    50% {
        left: 60px;
        top: 0;
    }
    75% {
        left: 90px;
        top: 30px;
    }
    100% {
        left: 120px;
        top: 0;
    }
}
The above code describes an animation made up of five keyframes. Each keyframe sets the position of the object. The element will move smoothly between these positions.

If you only have two states (the first and last), you can use simplified notation. The rotation keyframe below, for example, describes a full rotation from 0° to 360°, defined with two rotate() values of the transform property:
Two State Animation Markup
@keyframes rotation {
    from {
        transform: rotate(0deg);
    }
    to {
        transform: rotate(360deg);
    }
}
Important:
Keyframes only serve to describe the different states of the animation. This alone isn't enough. We also need to know how to apply the animation to an element. We'll get to this in the following lessons.

Animations
Animations are applied to HTML elements using the animation property.
To make an animation work, you need to set two sub-properties:
animation-name specifies the name of the @keyframes rule.
animation-duration sets out the total duration of the animation.

div {
    animation-name: move;
    animation-duration: 2s;
}
This code will start an animation made from a @keyframes at-rule called move, which will last for two seconds.
You can also use the following shorthand:
 
div {
    animation: move 2s;
}
There are many sub-properties in the animation property group that you can use to define the behavior of the animation:
animation-timing-function: You can use this property to specify the trajectory of the animation as a function of progression over time. We studied something similar for the transition property. You can set it as a Bezier cube or with keywords (linear, ease-in, ease-in-out, ease, ease-out).
animation-delay: The delay before the animation starts (in seconds).
animation-iteration-count: Specifies how many times the animation will play. This property takes an integer value, but you can use the infinite keyword if you want your animation to repeat indefinitely.
animation-direction: The direction of the animation. There are four possible values for this, and they can be set with keywords. You can play your animation from start to end, with the value normal; from end to start with reverse; from start to end and back to start with alternate; or from end to start and back to end with alternate-reverse.
animation-fill-mode: Indicates how the element will behave after the animation finishes. A value of forwards keeps the element in its final state, while backwards returns the element to its initial state. The most complicated option is both, where first of all, the element is set to the state of the first frame. The animation then begins after the amount of time specified in the animation-delay property, and then at the end of the animation, the final state of the element is preserved.
A visual representation of animation-fill-mode
The example below shows three different versions of the same animation.
Before the animation starts, the block with the ball has a soccer ball set as the background. In the first frame of the animation, the background changes to a baseball, then it gradually morphs into a basketball, becoming a full basketball in the final frame. There is also a certain time delay specified for the animation.
forwards mode: First, we have the animation delay while the ball is a soccer ball, then the ball switches to the first frame (baseball). When the whole animation is complete, the final frame is preserved.
backwards mode: The first frame (baseball) sits until the delay completes, and then the animation starts, continuing until it ends at the final frame. However, in this case, the final frame isn't preserved, and the ball returns to its original position, becoming a soccer ball again.
both mode: This animation behaves similarly to forwards mode. We start off immediately with the first frame (baseball), then comes the delay. When the whole animation is finished, the final frame is preserved.
animation-play-state: Specifies whether or not the animation has started. The running value launches the animation, while paused stops it. This property is often controlled through JavaScript, starting and stopping the animation when different events occur.
You can also assign the following values to virtually all CSS properties:
initial: This ensures that the property will have its default value when the page initially loads.
inherit: This means that the element will inherit the property value of its parent.
This can be useful in certain cases.
Here’s how a set of properties looks in full notation and shorthand:
Copy codeCSS
div {
    animation-name: move;
    animation-duration: 2s;
    animation-timing-function: ease-in-out;
    animation-delay: 1s;
    animation-iteration-count: 3;
    animation-direction: reverse;
    animation-fill-mode: forwards;
    animation-play-state: running;
}

div {
    animation: move 2s ease-in-out 1s 3 reverse forwards running;
}
When you write out the properties out in shorthand, the order in which they appear doesn't matter. 
 
The only exception is that 
animation-delay has to come after animation-duration,
 since they have the same unit of measurement.
You can also assign multiple animations to one element by separating them with a comma.

div {
    animation: move 2s, rotation 5s;
}


