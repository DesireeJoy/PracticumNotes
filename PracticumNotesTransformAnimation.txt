Intro to Animation and Transform with CSS
Transform
div {
    transform: matrix(2, 3, 4, 5, 6, 7);
}
The first parameter scales the element's width. The value of 2 above, for example, will double the element's size along the x-axis. It is equivalent to the transform value scaleX().
The second parameter 3 describes the vertical skew of an element in degrees. A positive value raises the left edge of the element and lowers the right, while a negative value does the opposite. This is equivalent to the transform value skewY().
The third parameter 4 is the horizontal skew in degrees. A positive value skews the top of the element to the left, and a negative value to the right. It is equivalent to the transform value skewX().
The fourth parameter scales the element's height. The value of 5 expands it along the y-axis by a factor of 5. It is equivalent to the transform value scaleY().
The fifth parameter 6 describes the translation of an element along the x-axis in pixels. It is equivalent to the transform value translateX().
The sixth parameter 7 describes the translation of an element along the y-axis in pixels. It is equivalent to the transform value translateY().
 
transform: translate(10px, 20px); /* moves the object 10 pixels to the right and 20 pixels down */
transform: scale(1.5, 0.5); /* enlarges the object by a factor of 1.5 horizontally and halves it vertically */
transform: rotate(30deg); /*rotates the object 30 degrees clockwise */
transform: skew(30deg, 40deg); /* skews the top side of the object 30 degrees to the left, the bottom side 30 degrees to the right, the left side 40 degrees up, and the right side 40 degrees down */

translate() is specified in pixels, but they can also be defined in relative values.
scale() is defined relative to 1. The value 1 signifies a ratio of one to one, meaning the element will not change. Values larger than 1 expand the object, while numbers less than 1 contract it.
rotate() and skew() can be defined in degrees. Negative values are allowed and are used for counterclockwise rotations and skews to the right.
The transform property can also be applied in three dimensions to create a virtual 3D effect on the screen. We won't get into the details of this here. For now, we'll just stick to the basics.

Smoothing out Transitions
transition-property describes which property is being changed.
transition-duration specifies the transition time in seconds.
transition-timing-function defines how the transition animation will behave (speed up, slow down, or move linearly).
transition-delay is the number of seconds between the change in the element's state and the start of the animation.
div {
    background-color: black;
    transition-property: background-color;
    transition-duration: 1s;
    transition-timing-function: linear;
    transition-delay: 2s;
}
 
div:hover {
    background-color: white;
}
Shorthand Version

div {
    background-color: black;
    transition: background-color 1s linear 2s;
}

div:hover {
    background-color: white;
}

Timing-function Keywords
ease
linear
ease-in
ease-out
ease-in-out
transition-timing-function: cubic-bezier(1,.2,.52,.46);
Link to custom timing graphs
https://cubic-bezier.com/#.17,.67,.83,.67

One thing to keep in mind about the transition property is that it performs best when applied to an element's canonical CSS rule rather than to its :hover rule.

Shadows
Shadows are a useful design tool. They can be applied to elements as well as text. The box-shadow property is used for block shadows.
The sequence of values for shadow properties for both text and blocks goes as follows:
Horizontal shadow offset (negative values create a shadow to the left of the object, and positive values to the right).
Vertical shadow offset (negative values create a shadow above the object, and positive values below).
Blur radius (the bigger the value, the bigger and lighter the shadow).
Shadow color (set the same way as text or background color).

In code, values are written as follows:
Copy codeCSS
div {
            box-shadow: 5px 6px 7px red;
}

h1 {
        text-shadow: 5px 6px 7px red;
}
In both examples, the shadow is offset 5px to the right and 6px down, has a blur radius of 7px, and is red in color.

Linear Gradients
 gradient allows you to fill a block with color in such a way that one color (called a color stop) smoothly transitions into another between fixed points.
In CSS, gradients are set by using the background-image property. In fact, a gradient is essentially a basic background image, except that it's generated with code.
There are two types of gradients: linear and radial.
Linear
Linear gradients are defined in code using the linear-gradient() value for background-image.

In the most simple cases, two colors are set in parentheses, separated by a comma. These are the starting and ending colors. The browser creates a smooth transition between them.
Copy codeCSS
div {
    background-image: linear-gradient(#0078FF, #C2E3E3);
}
By default, the color transition goes from top to bottom, but this can be changed. One option is to rotate the gradient by a certain amount of degrees.
For example:
Copy codeCSS
div {
    background-image: linear-gradient(90deg, #0078FF, #C2E3E3);
}
This rotates the gradient 90 degrees.

There are special keywords for the most frequently used directions, which you can use instead of degrees.

To build more complex gradients, you can use more than two colors:
Copy codeCSS
div {
    background-image: linear-gradient(#0B2337, #126DDC, #76C2E0, #D1DC9D, #F09174);
}
After setting each color, you can set the interval at which the colors should be applied. The first value is the starting point of the direction you’ve set, and the second is the final point.
Copy codeCSS
div {
    width: 300px;
    height: 300px;
    background-image: linear-gradient(#0078FF 0px 100px, #B4DEEF 100px 200px, #FF5A0A 200px 300px);
}

You can also define stop points as percentages:
Copy codeCSS
div:first-of-type {
    width: 300px;
    height: 300px;
    background-image: linear-gradient(#0078FF 20%, #C2E3E3 100%);
}
div:last-of-type {
    width: 300px;
    height: 300px;
    background-image: linear-gradient(#0078FF 80%, #C2E3E3 100%);
}
Result:

You can create some very interesting effects by combining these methods. We've only gone through the most basic gradient settings, which are usually enough for most purposes.
Radial Gradients
While colors in a linear gradient change in one direction, with radial gradients, the color changes outwards in all directions starting from a given central point. The gradient itself can be either circular or elliptical.
The most basic radial gradient is set with the radial-gradient() value as follows:
 
Copy codeCSS

div {
    background-image: radial-gradient(#0078FF, #C2E3E3);
}

The default starting point for a radial gradient is the middle of the block, but this can be changed by setting a position with the keyword at (i.e. "at this point").
Copy codeCSS
div {
    width: 300px;
    height: 300px;
    background-image: radial-gradient(at 40px 50px, #0078FF, #C2E3E3);
}
This code will position the center of the gradient 40px to the right of the left edge of the block and 50px below the upper edge.

Just like with a linear gradient, you can define colors and stop points as percentages:
Copy codeCSS
div {
    width: 300px;
    height: 300px;
    background-image: radial-gradient(#002918 10%, #B4DEEF 20%, #FFFFFF 50%, #FF5831 100%);
}
or in pixels:
Copy codeCSS
div {
    width: 300px;
    height: 300px;
    background-image: radial-gradient(#002918 50px, #B4DEEF 70px, #FFFFFF 100px, #FF5831 200px);
}
You can also set exact intervals to create a hard-edged gradient, where the color transition is not smooth:
Copy codeCSS
div {
    width: 300px;
    height: 300px;
    background-image: radial-gradient(#002918 0px 20px, #B4DEEF 20px 40px, #FFFFFF 40px 60px, #FF5831 60px 80px);
}

By setting a width and height in the first parameter of the parentheses, you can either stretch or collapse the ellipse.
Copy codeCSS
div {
    width: 300px;
    height: 300px;
    background-image: radial-gradient(40px 100px, #0078FF, #C2E3E3);
}
or
Copy codeCSS
div {
    width: 300px;
    height: 300px;
    background-image: radial-gradient(100px 40px, #0078FF, #C2E3E3);
}

There's documentation available that outlines many more things you can do with radial gradients. For now, we've just introduced you to the most basic features.

Block Overflow
Let’s find out what happens when you try to place a block that's 500×500 in a block that’s 300×600.
First we're going to nest a div element with an inner class in a parent div with an outer class:
Copy codeHTML
<div class="outer">
    <div class="inner"></div>
</div>
Now, using a CSS rule, we set the width of the inner block to be wider than the outer block. We'll also set different colors for each of them:
Copy codeCSS
.outer {
    width: 300px;
    height: 600px;
    background-color: rgb(1, 163, 114);
}

.inner {
    width: 500px;
    height: 500px;
    background-color: rgba(0, 120, 255, .8);
}
Result:

When a large block goes beyond the dimensions of its smaller parent, the whole block is still visible by default. In CSS, this situation is called an overflow. When this happens, we can define the parent block's behaviour with the overflow property, which has three possible values:
auto is the default value.
scroll hides the areas outside the boundaries of the block, but allows you to scroll inside the parent block to see the rest of the overflowed element.
hidden hides the parts that don't fit.

You can also set more specific values with these sub-properties:
overflow-x defines the horizontal behavior.
overflow-y defines the vertical behavior.
In this example, we've added an overflow property with a value of hidden:
Copy codeCSS
.outer {
    width: 300px;
    height: 600px;
    background-color: rgb(1, 163, 114);
    overflow: hidden;
}

.inner {
    width: 500px;
    height: 500px;
    background-color: rgba(0, 120, 255, .8);
}
Anything that doesn't fit the parent's dimensions is hidden:

Keyframes
So far in this chapter, we've only discussed simple transformations. Now it's time to move on to more complicated ones. This is where keyframes come in.
First of all, let’s look at how animations work in general. A movie, for example, is just a collection of still images. They change so quickly that it seems like the picture is moving. Animations work in a similar way. The browser renders different states of the animated object one after another at such a high speed, that all you see is a smooth transition. Just like with movies, each of these states is called a frame.
In the second lesson of this chapter, we looked at this example:
Copy codeCSS
div {
    background-color: black;
    transition: background-color 2s linear 0s;
}
This code tells the <div> element to smoothly change its color. The animation has two keyframes. There's the first frame, in which the background is transparent, and the last frame, where it's black. The animation shows the element’s state changing smoothly from one to the other.
To recap, an animation is made up of frames. Keyframes are the frames where we set the states of an element that we want to transition between. All the intermediate frames required to make these transitions smooth are automatically generated by the browser.
You can create an animation using keyframes as follows:
1. Describe the state of the element in each keyframe.
2. Use a selector to choose the element you want to animate.
3. Set specific behavior for the animation, such as how many times it should repeat, the duration, and timing function. We'll get into this in more detail later.
Stage 1: Describing the transformation
Keyframes are declared with the @keyframes at-rule. All at-rules are written after the @ sign.
You must include a name when you declare a keyframe, as you'll need it to implement the animation. The name comes right after the at-rule, with a space:
@keyframes name_of_keyframe.

Keyframe rules are followed by a pair of curly braces, where the "body" of the keyframe goes.

@keyframes name_of_keyframe {
    <rules specifying changes to the style go here>
}
The element's CSS declarations are specified in curly brackets for each keyframe. Keyframes are written as percentages. 0% refers to the start of the animation, 50% to the middle, 100% to the end, and so on.

Multiple State Animation Markup
@keyframes move {
    0% {
        left: 0;
        top: 0;
    }
    25% {
        left: 30px;
        top: 30px;
    }
    50% {
        left: 60px;
        top: 0;
    }
    75% {
        left: 90px;
        top: 30px;
    }
    100% {
        left: 120px;
        top: 0;
    }
}
The above code describes an animation made up of five keyframes. Each keyframe sets the position of the object. The element will move smoothly between these positions.

If you only have two states (the first and last), you can use simplified notation. The rotation keyframe below, for example, describes a full rotation from 0° to 360°, defined with two rotate() values of the transform property:
Two State Animation Markup
@keyframes rotation {
    from {
        transform: rotate(0deg);
    }
    to {
        transform: rotate(360deg);
    }
}
Important:
Keyframes only serve to describe the different states of the animation. This alone isn't enough. We also need to know how to apply the animation to an element. We'll get to this in the following lessons.


